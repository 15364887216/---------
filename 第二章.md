个人学习计算机组成原理的理解笔记，仅供参考学习使用
# 第二章 数据的表示和运算
这一章我们有两个重要的问题：
- **数据如何在计算机中表示?**
- **运算器如何实现数据的算数、逻辑运算?**

## 进位计数值
在探讨这两个问题之前我们要先知道数据的进制，进制很好讲，我们人类最符合直觉的当然是十进制（毕竟我们有十根手指），用0~9共十个符号表示，使用**逢十进一**的进位计数制。
以十进制数975.36来举例：
可以表示为

1. **975.36等价于**：

$$
   9 \times 100 + 7 \times 10 + 5 \times 1 + 3 \times 0.1 + 6 \times 0.01 = 975.36
$$
   这个表达式展示了如何将一个十进制数分解成各个位数的乘积和。

2. **由此我们可以推断出十进制数可以等价为**：
$$
   K_n \times 10^n + K_{n-1} \times 10^{n-1} + \ldots + K_2 \times 10^2 + K_1 \times 10^1 + K_0 \times 10^0 + K_{-1} \times 10^{-1} + K_{-2} \times 10^{-2} + \ldots + K_m \times 10^{-m}
$$
   这个表达式是一个多项式的通用形式，表示一个数在科学记数法中的展开形式。

以此类推，其他进制也采用类似的方法，计算机使用0和1两个字符，所以是二进制，即**逢二进一**,同样还有我们的时间，可以用十二进制。由此我们可以用***r***来代替具体的进制，一个服从于***r***进制的数
$$
K_n  K_{n-1} \ldots K_2 K_1 K_0 
$$
可以表示为

$$
K_n \cdot r^n + K_{n-1} \cdot r^{n-1} + \ldots + K_2 \cdot r^2 + K_1 \cdot r^1 + K_0 \cdot r^0
$$

### 任意进制-->十进制
$$
K_n \cdot r^n + K_{n-1} \cdot r^{n-1} + \ldots + K_2 \cdot r^2 + K_1 \cdot r^1 + K_0 \cdot r^0
$$
上式的运算结果用十进制表示就可以实现任意进制到十进制的互转化，举几个例子：
1.**二进制表达式（10010010.110）**: 
$$
[ 1 \times 2^7 + 0 \times 2^6 + 0 \times 2^5 + 1 \times 2^4 + 0 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = 146.75 ]
$$
2.**八进制表达式（251.5）**:
$$
 [ 2 \times 8^2 + 5 \times 8^1 + 1 \times 8^0 + 5 \times 8^{-1} = 168.625 ]
 $$
3.**十六进制表达式（AE86.1）**:
$$
 [ 10 \times 16^3 + 14 \times 16^2 + 8 \times 16^1 + 6 \times 16^0 + 1 \times 16^{-1} = 44678.0625 ]
$$
 ```
 补充一下十六进制，0~9与十进制相同，10~15用英文字母A~F表示
 ```
### 二进制<-->八进制,十六进制
在计算机组成原理中，除了十进制我们最常用到的就是二进制和八，十六进制。
我们知道二进制只有0，1两个数，需要三个二进制位才能表达十进制的0~7，即000 ~ 111，因此二进制转换为八进制时需要**3位二进制数对应一位八进制数**，同理十六进制需要**4位二进制数对应一位十六进制数**，反之亦然。
![进制转换](/image/2/jzzh.png)
不同进制的数字同时出现我们需要加以区分，方法是上括号带一个进制***r***的角标。
![进制书写](/image//2/jzsx.png)

### 十进制<-->任意进制
要将十进制数转换为任意进制（如二进制、八进制、十六进制等），可以使用以下公式和步骤：

#### 公式和步骤

1. **整数部分转换**：
   - 使用除法取余法，将十进制数不断除以目标进制，记录每次的余数，直到商为0。
   - 公式表示为：
     $$
     \text{余数} = \left( \frac{N}{r} \right) \mod r
     $$
     其中，\(N\) 是当前的十进制数，\(r\) 是目标进制，\(\mod r\) 表示取余操作。

2. **小数部分转换**：
   - 使用乘法取整法，将小数部分不断乘以目标进制，记录每次的整数部分，直到小数部分为0或达到所需精度。
   - 公式表示为：
     $$
     \text{整数部分} = \left( f \times r \right) \mod 1
     $$
     其中，\(f\) 是当前的小数部分，\(r\) 是目标进制，\(\mod 1\) 表示取小数部分。

#### 示例

假设我们要将十进制数 156.625 转换为二进制：

1. **整数部分**：
   - 156 ÷ 2 = 78 余 0
   - 78 ÷ 2 = 39 余 0
   - 39 ÷ 2 = 19 余 1
   - 19 ÷ 2 = 9 余 1
   - 9 ÷ 2 = 4 余 1
   - 4 ÷ 2 = 2 余 0
   - 2 ÷ 2 = 1 余 0
   - 1 ÷ 2 = 0 余 1

   逆序排列余数：`10011100`

2. **小数部分**：
   - 0.625 × 2 = 1.25 取整数部分 1
   - 0.25 × 2 = 0.5 取整数部分 0
   - 0.5 × 2 = 1.0 取整数部分 1

   顺序排列整数部分：`0.101`

3. **组合结果**：
   - 整数部分：`10011100`
   - 小数部分：`0.101`

   最终结果：`10011100.101`

整数部分的操作本质：

$$
(K_n \cdot r^n + K_{n-1} \cdot r^{n-1} + \ldots + K_2 \cdot r^2 + K_1 \cdot r^1 + K_0 \cdot r^0) / r = K_n \cdot r^{n-1} + K_{n-1} \cdot r^{n-2} + \ldots + K_2 \cdot r^1 + K_1 \cdot r^0 + \ldots + K_0
$$

其中，任一数码位 \(K_i < r\)。

上式每次操作都会有一个 \(K_0\) 作为余数被分出，并作为新进制中的 \(K_0, K_1, K_2, K_3, \ldots\)。

而剩余的部分再次作为被除数加入运算,因此讲最后得出的余数按得出顺序从晚到早排列就可以得出结果，我们写竖式的时候就是**从下到上**排列。

![进制转换1](/image//2/jzzh1.png)

**小数部分同理，其本质为通过，乘或除*r*来获得一个“多余的数”K0,并按一定的顺序排列，只不过整数除法得到的余数是目前最小的低位，小数乘法得到的是目前最高的高位**
![进制转换1](/image//2/jzzh2.png)

当然我们心算快的人可以用一种**暴力拼凑**的方法，比如最常见的十进制-->二进制，我们知道：
$$
2^1 = 2,2^2 = 4,2^3 = 8,2^4 = 16\ldots2^{10} = 1024
$$
```
这里建议玩一个小游戏2048，快速上手，可以搜在线进制转换自己练习。
```
假设有一个数是257，那么
$$
（257）_{10} = （256+1）_{10} =（2^8+2^0）{10} =（100，000，001）_{2}
$$
**熟练应用是一个相当不错的应试技巧，但是时间够的话还是稳妥些。**
现代计算机主要使用CMOS（互补金属氧化物半导体）技术，而不是TTL（晶体管-晶体管逻辑）技术。

## 原码、反码、补码、移码
![机器数](/image//2/jqm.png)
计算机不可能按十进制为我们存储数据，我们说的原码、反码、补码、移码就是数据在计算机中存储的形式。

### 原码的表示与加法运算
#### 数字电路的知识补充
这里涉及到数字逻辑电路的知识，作为一个负责任的人我会帮大家先补习一下数电的知识。
在讲解之前我们返回第一章，我们知道逻辑元件的发展经历了**从电子管到晶体管再到集成电路**的发展历程，而我们也提到过一个叫做***封装***的概念，接下来我们通过一个游戏来具体了解这些逻辑电路是怎么一步步封装起来的。
```
这里用到的游戏叫做Truing complete（图灵完备）,可以自己在steam上买一个玩，经常打折，很便宜。
```
首先我们先了解一个东西，现代计算机主要使用CMOS（互补金属氧化物半导体）技术与TTL（晶体管-晶体管逻辑）技术，最常见的是CMOS，他们互有优劣，使用场景和优劣分析可以自行查阅，使用CMOS最大的原因是因为**省钱**。
**COMS**:
![COMS](/image//2/COMS.png)
**TTL**：
![TTL](/image//2/TTL.png)
他们共同的作用是：
- 当输入为高电平（1）时，NMOS导通（晶体管导通），输出为低电平（0）。
- 当输入为低电平（0）时，PMOS导通（晶体管截止），输出为高电平（1）。

而通过这个元件，我们就可以组建我们电脑中的基本元件。
****
以下是非门、与门、或门、与非门和或非门的真值表：

### 非门（NOT Gate）
| 输入 (A) | 输出 (Y) |
|----------|----------|
|    0     |    1     |
|    1     |    0     |

### 与门（AND Gate）
| 输入 (A) | 输入 (B) | 输出 (Y) |
|----------|----------|----------|
|    0     |    0     |    0     |
|    0     |    1     |    0     |
|    1     |    0     |    0     |
|    1     |    1     |    1     |

### 或门（OR Gate）
| 输入 (A) | 输入 (B) | 输出 (Y) |
|----------|----------|----------|
|    0     |    0     |    0     |
|    0     |    1     |    1     |
|    1     |    0     |    1     |
|    1     |    1     |    1     |

### 与非门（NAND Gate）
| 输入 (A) | 输入 (B) | 输出 (Y) |
|----------|----------|----------|
|    0     |    0     |    1     |
|    0     |    1     |    1     |
|    1     |    0     |    1     |
|    1     |    1     |    0     |

### 或非门（NOR Gate）
| 输入 (A) | 输入 (B) | 输出 (Y) |
|----------|----------|----------|
|    0     |    0     |    1     |
|    0     |    1     |    0     |
|    1     |    0     |    0     |
|    1     |    1     |    0     |

这些真值表展示了每种逻辑门在不同输入情况下的输出结果。
*****
我们发现CMOS的特性完美符合我们的非门的真值表，而在数字逻辑电路中我们采用一些特定的符号来表示这些门，本笔记主要用国外流行图形符号。
![逻辑门电路](/image/2/ljmdl.png)
```
现代计算机的具体实现可以参考知乎文章
1.2计算机组成原理-逻辑门 - Bytehub的文章 - 知乎
https://zhuanlan.zhihu.com/p/429544891
更详细的理解可可以参考
【【计算机科学速成课】[40集全/精校] - Crash Course Computer Science】 https://www.bilibili.com/video/BV1EW411u7th/?p=3&share_source=copy_web&vd_source=ac577b966f2e9f3eeaecc61d44a9ddd9
```
我们讲晶体管的实物抽象为这样一张图片(图片来源为计算机科学速成课)，此时一个单独的晶体管为**非门**。
他类似一个开关，**current**是电流，当输入为1时，电路打开，电流接地，所以输出是0，即**off**。反之电流通过，输出为**on**。

![Not Gate](/image/2/NotGate.png)

同样我们可以用两个晶体管**串联**起来组成**与门**

![And Gate](/image/2/AndGate.png)

类似地，我们可以通过**并联**的方式组成**或门**

![Or Gate](/image/2/OrGate.png)

现在我们将上面这三个门作一次封装，即变为上面提到的逻辑符号，将与门与非门串联起来可以得到**与非门**（就是与门前加了个小圆圈，很好懂对吧？）。

![Not And Gate](/image/2/NotAndGate.png)

事实上我们可以用**与非门**做基础得到所有的门，**Truing complete（图灵完备）** 这款游戏就是这么做的，我们来看一些游戏截图。
- 用与非门表示非门
  ![Or Gate](/image/2/TC1.png)
- 表示与门（操作有点像套娃，电路很有意思对吧）
  ![And Gate](/image/2/TC2.png)
- 用与非门表示或门
  ![Or Gate](/image/2/TC3.png)
我们还可以以此为基础做更多的操作！
比如**或非门**
![OrNot Gate](/image/2/TC4.png)
```
剩下的太过简单了，基本是几个门的相互组合，其实不难对吧。
```
我们再看最后一个**异或门**

![exclusive-OR gate](/image/2/TC5.png)
### 加法器的诞生
OK!我们现在复习（或学习）了一下基本的逻辑门电路，我们要探讨一下一位二进制加法是如何进行运算的。
我们不考虑进位的情况，2进制加法可以类比十进制加法，0+0=0，0+1=1，1+0=1，他们的结果都可以用一位二进制数来表示，问题是，1+1=10，最后一种情况多了一种位，因此我们结果需要多留一位来保留进位，其真值表如下。

包括进位（Carry）和结果（Sum）：

| 输入A | 输入B | 进位（Carry） | 结果（Sum） |
|-------|-------|---------------|-------------|
|   0   |   0   |       0       |      0      |
|   0   |   1   |       0       |      1      |
|   1   |   0   |       0       |      1      |
|   1   |   1   |       1       |      0      |

而这个结果在数字电路中非常简单，只要两个逻辑门元件就能表示，不考虑进位只需要进行一次异或运算，而进位仅在都为1时成立，需要一个异或门和一个与门。

![half-add unit](/image/2/TC6.png)
恭喜你！我们目前做出了一个**半加器**！它用来计算1位二进制的运算结果，我们不妨再多加一个输出，三个输出的情况下共有8种结果，半加器显然不够看。

以下是全加器（Full Adder）的真值表，包括两个输入位（A和B）、一个进位输入（Carry In，简称Cin）、一个进位输出（Carry Out，简称Cout）和一个和（Sum）：

| 输入A | 输入B | 进位输入 (Cin) | 进位输出 (Cout) | 和 (Sum) |
|-------|-------|----------------|-----------------|----------|
|   0   |   0   |       0        |        0        |     0    |
|   0   |   0   |       1        |        0        |     1    |
|   0   |   1   |       0        |        0        |     1    |
|   0   |   1   |       1        |        1        |     0    |
|   1   |   0   |       0        |        0        |     1    |
|   1   |   0   |       1        |        1        |     0    |
|   1   |   1   |       0        |        1        |     0    |
|   1   |   1   |       1        |        1        |     1    |

现在是不是开始头疼了？没关系，其实只要额外在半加器的基础上继续做异或运算，并保证进位在有两个或三个输出为1时成立就好啦。

![full adder](/image/2/TC7.png)
恭喜你做出了有三个输出的**全加器**！
现在线路已经开始复杂了，我们对全加器做**一次封装**，用下面这个符号表示全加器。
![full adder](/image/2/fulladder.png)。
事实上计算机不可能只用三个输入只进行这么低等的加法，我们常用的是**八位加法器**，他的输入有**两个八位输入和来自其他加法器的一位进位**，想想头就大了！但是我们已经对全加器做了封装，其实只需要对两个八位输入拆分成8个1位的输入并于进位输入进行**总共8次加法**，将结果合并起来就好了。
![full adder](/image/2/8bitfulladder.png)。
**我们应该有听过0或1对应计算机内部一个开关的闭合或者高低电平，所以拆分和合并很简单，只要一个分线器和集线器把内部的电路分开或集合就好了，集线器和分线器这里不是重点。**
****
### 原码运算与其缺陷
我们成功实现了一个**8位加法器**，**无符号8位二进制整数**的输入与范围是0 ~ 255；输出范围考虑到进位，范围是0~510（9位输出不可能都是1）.

**原码就是普通的二进制代码**，同上，我们可以很轻松地根据原码加法的原理制造出加法器。
#### 原码的缺陷
有**无符号整数**，自然有**有符号整数**，也就是我们说的**正数和负数**，数字部分很好表示，但**正负号**呢？
很简单，正负号同样只有两种情况，我们同样可以用0和1代替，**0表示正数，1表示负数**。
同样按之前的8位表示，我们可以匀出一种作**符号位**，剩余的七个部分则是**数值位**。
那么他的表示范围就是：11111111 ~ 01111111，即-127~+127

这时问题出现了：原码表示中出现了 **+0** 和 **-0** 两种情况！如果我们按照之前的加法器设计对有符号数进行加减，那么会出现两个问题：
1.**正数+负数由于符号位相加是1导致结果是负数**；

2.**数值位相加进位会影响到符号位，也会影响到进位，数值位溢出会进位到符号位而不是加法器的进位上等各种相对复杂的后果。**

### 反码的诞生
反码的诞生与计算机处理负数的需求密切相关。在计算机科学中，反码是一种用于表示有符号整数的二进制编码方法。以下是反码的由来和作用：

#### 1. **原码的局限性**
原码（Sign-Magnitude）是最简单的有符号数表示方法，其中最高位表示符号位（0表示正数，1表示负数），其余位表示数值部分。然而，原码有一些局限性：
- 存在两个零（+0和-0），这会导致计算复杂性增加。
- 加减运算需要特殊处理，增加了硬件设计的复杂性。

#### 2. **反码的引入**
为了克服原码的局限性，反码（Ones' Complement）被引入。反码的表示方法是将正数的每一位取反（0变1，1变0）来表示负数。例如：
- 正数：+5 的二进制表示为 00000101
- 负数：-5 的反码表示为 11111010

#### 3. **反码的优点**
- 反码只有一个零（00000000），消除了原码的双零问题。
- 反码的加减运算相对简单，只需进行二进制加法和取反操作。

#### 4. **反码的局限性**
尽管反码解决了一些原码的问题，但它仍然存在一些缺点：
- 存在负零（11111111），这在某些计算中可能会引起混淆。
- 进位处理复杂，特别是在加法运算中需要考虑进位。

#### 5. **补码的出现**
为了进一步简化计算和消除负零问题，补码（Two's Complement）被引入。补码通过在反码的基础上加1来表示负数。例如：
- 正数：+5 的二进制表示为 00000101
- 负数：-5 的补码表示为 11111011

补码不仅解决了反码的负零问题，还简化了加减运算，使得计算机硬件设计更加高效。

