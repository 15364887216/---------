**译码器补充**：
![](/image/3/ymq.png)
![](/image/3/ymq1.png)

# 主存储器和CPU的连接
![](/image/3/现在的计算机.png)
经过我们之前的学习我们指定现代计算机大致的抽象连接方式。
![](/image/3/存储器芯片.png)
也知道存储器芯片的输入输出信号如何控制的，现在我们来看一些拓展的情况

## 双端口RAM&&多模块存储器
这里408已经删掉了，只是简单提一下：
当然可以！让我们用简单的语言来解释一下：

### 双端口RAM
双端口RAM是一种特殊的存储器，它有两个独立的端口，每个端口都可以同时进行读写操作。这意味着你可以在同一时间从一个端口读取数据，同时从另一个端口写入数据。这种设计可以大大提高数据访问的效率，特别是在需要频繁读写的应用中⁶⁷。

### 多模块存储器
多模块存储器是一种通过将多个存储模块并行工作来提高存储器性能的方法。它可以分为两种主要类型：

1. **单体多字存储器**：一次可以从一个存储模块中读取多字数据。
2. **多体低位交叉存储器**：将数据分散存储在多个模块中，并行读取多个模块的数据，从而提高数据吞吐量。

这种设计可以有效地提高存储器的访问速度和系统的整体性能。

通俗地来说你可以通过两个端口同时读写内存条，相同的内存，使用两个8GB的内存条，数据可以同时读写，这样比容量相同的16GB内存条速度要快两倍。
## 存储器容量拓展
存储器芯片的容量是有限的，为了满足实际存储器的容量要求，需要对存储器进行扩展。

主存扩展：将存储芯片连在一起组成足够的容量。

存储器容量扩展的主要方法有：
- 位扩展：只加大字长，而存储器的字数与存储器芯片字数一致，对所有片子使用共同片选信号；
  
- 字扩展：仅在字向扩充，而位数不变。需由片选信号来区分各片地址。
字位扩展：一个存储器的容量假定为M×N位，若使用l×k 位的芯片(l＜M，k＜N)，需要在字向和位向同时进行扩展。此时共需要(M/l)×(N/k)个存储器芯片。

![](/image/3/ccqxp1.png)
### 位拓展
重申一次，数据总线的位数就是MDR的位数也就是存储字长，虽然我们考试是这么写的，但事实上只是我们尽量让他们相等，原因是如果他们不相等会限制数据总线的性能或者内存信息传输不到位。
![](/image/3/ccqxp2.png)
而面对数据总线大于存储字长的时候，我们可以采用位拓展，也就是**增大存储器的字数**
![](/image/3/wtz1.png)
假设一种极端情况，你有一个8K*1bit的芯片，而对方的数据总线却有8条，这意味着你有7条线没有用到，而我们就可以再接入一个相同的芯片来用上剩余的数据总线…………
![](/image/3/wtz2.png)
这其实没什么难的，本质就是我们前面做的将多个门锁矩阵封装成一个RAM的过程。

### 字拓展
![](/image/3/ztz1.png)
现在我们设想我们有一个8K*8bit的芯片，很显然他的数据总线是8位对应芯片的8bit，已经够了，我们不需要再用位拓展的方式了，但现在存在一个问题。8K即2^13^，代表我们能用13位数字表示该芯片的地址，但地址是16位，显然有3位没有用上，**面对地址总线没用上的情况我们用字拓展**。

#### 线选法
![](/image/3/ztz3.png)
我们可以通过多个芯片连接的方式，利用剩余的地址线对其进行选择，问题如图，假设多余的地址线出现00或11的情况，会导致两个芯片同时读或谁都不读的情况，很明显这回出错，我们可以采用更复杂一些的方式。
#### 译码片选法
事实上也和前面做过的一样，我们可以用**译码片选法**，同样连接多个相同的芯片，利用一个译码器将剩下的地址线部分连接起来，通过空闲部分的地址线信号经过译码器选择指定的芯片存储，没有用到的三位地址也就变成了指定芯片的**代号**。

![](/image/3/ztz2.png)