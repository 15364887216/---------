<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
个人学习计算机组成原理的理解笔记，仅供参考学习使用
# 第二章 数据的表示和运算
这一章我们有两个重要的问题：
- **数据如何在计算机中表示?**
- **运算器如何实现数据的算数、逻辑运算?**

## 进位计数值
在探讨这两个问题之前我们要先知道数据的进制，进制很好讲，我们人类最符合直觉的当然是十进制（毕竟我们有十根手指），用0~9共十个符号表示，使用**逢十进一**的进位计数制。
以十进制数975.36来举例：
可以表示为

1. **975.36等价于**：

$$
9 \times 100 + 7 \times 10 + 5 \times 1 + 3 \times 0.1 + 6 \times 0.01 = 975.36
$$

这个表达式展示了如何将一个十进制数分解成各个位数的乘积和。

2. **由此我们可以推断出十进制数可以等价为**：

$$
K_n \times 10^n + K_{n-1} \times 10^{n-1} + \ldots + K_2 \times 10^2 + K_1 \times 10^1 + K_0 \times 10^0 + K_{-1} \times 10^{-1} + K_{-2} \times 10^{-2} + \ldots + K_m \times 10^{-m}
$$

这个表达式是一个多项式的通用形式，表示一个数在科学记数法中的展开形式。

以此类推，其他进制也采用类似的方法，计算机使用0和1两个字符，所以是二进制，即**逢二进一**，同样还有我们的时间，可以用十二进制。由此我们可以用***r***来代替具体的进制，一个服从于***r***进制的数

$$
K_n  K_{n-1} \ldots K_2 K_1 K_0 
$$

可以表示为

$$
K_n \cdot r^n + K_{n-1} \cdot r^{n-1} + \ldots + K_2 \cdot r^2 + K_1 \cdot r^1 + K_0 \cdot r^0
$$

### 任意进制-->十进制
$$
K_n \cdot r^n + K_{n-1} \cdot r^{n-1} + \ldots + K_2 \cdot r^2 + K_1 \cdot r^1 + K_0 \cdot r^0
$$
上式的运算结果用十进制表示就可以实现任意进制到十进制的互转化，举几个例子：
1.**二进制表达式（10010010.110）**: 
$$
[ 1 \times 2^7 + 0 \times 2^6 + 0 \times 2^5 + 1 \times 2^4 + 0 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = 146.75 ]
$$
2.**八进制表达式（251.5）**:
$$
 [ 2 \times 8^2 + 5 \times 8^1 + 1 \times 8^0 + 5 \times 8^{-1} = 168.625 ]
 $$
3.**十六进制表达式（AE86.1）**:
$$
 [ 10 \times 16^3 + 14 \times 16^2 + 8 \times 16^1 + 6 \times 16^0 + 1 \times 16^{-1} = 44678.0625 ]
$$
 ```
 补充一下十六进制，0~9与十进制相同，10~15用英文字母A~F表示
 ```
### 二进制<-->八进制,十六进制
在计算机组成原理中，除了十进制我们最常用到的就是二进制和八，十六进制。
我们知道二进制只有0，1两个数，需要三个二进制位才能表达十进制的0~7，即000 ~ 111，因此二进制转换为八进制时需要**3位二进制数对应一位八进制数**，同理十六进制需要**4位二进制数对应一位十六进制数**，反之亦然。
![进制转换](/image/2/jzzh.png)
不同进制的数字同时出现我们需要加以区分，方法是上括号带一个进制***r***的角标。
![进制书写](/image//2/jzsx.png)

### 十进制<-->任意进制
要将十进制数转换为任意进制（如二进制、八进制、十六进制等），可以使用以下公式和步骤：

#### 公式和步骤

1. **整数部分转换**：
   - 使用除法取余法，将十进制数不断除以目标进制，记录每次的余数，直到商为0。
   - 公式表示为：
     
$$
\text{余数} = \left( \frac{N}{r} \right) \mod r
$$
     
其中，\(N\) 是当前的十进制数，\(r\) 是目标进制，\(\mod r\) 表示取余操作。

2. **小数部分转换**：
   - 使用乘法取整法，将小数部分不断乘以目标进制，记录每次的整数部分，直到小数部分为0或达到所需精度。
   - 公式表示为：
     
$$
\text{整数部分} = \left( f \times r \right) \mod 1
$$
     
其中，\(f\) 是当前的小数部分，\(r\) 是目标进制，\(\mod 1\) 表示取小数部分。


#### 示例

假设我们要将十进制数 156.625 转换为二进制：

1. **整数部分**：
   - 156 ÷ 2 = 78 余 0
   - 78 ÷ 2 = 39 余 0
   - 39 ÷ 2 = 19 余 1
   - 19 ÷ 2 = 9 余 1
   - 9 ÷ 2 = 4 余 1
   - 4 ÷ 2 = 2 余 0
   - 2 ÷ 2 = 1 余 0
   - 1 ÷ 2 = 0 余 1

   逆序排列余数：`10011100`

2. **小数部分**：
   - 0.625 × 2 = 1.25 取整数部分 1
   - 0.25 × 2 = 0.5 取整数部分 0
   - 0.5 × 2 = 1.0 取整数部分 1

   顺序排列整数部分：`0.101`

3. **组合结果**：
   - 整数部分：`10011100`
   - 小数部分：`0.101`

   最终结果：`10011100.101`

整数部分的操作本质：

$$
(K_n \cdot r^n + K_{n-1} \cdot r^{n-1} + \ldots + K_2 \cdot r^2 + K_1 \cdot r^1 + K_0 \cdot r^0) / r = K_n \cdot r^{n-1} + K_{n-1} \cdot r^{n-2} + \ldots + K_2 \cdot r^1 + K_1 \cdot r^0 + \ldots + K_0
$$

其中，任一数码位 \(K_i < r\)。

上式每次操作都会有一个 \(K_0\) 作为余数被分出，并作为新进制中的

$$
（K_0, K_1, K_2, K_3, \ldots）
$$

而剩余的部分再次作为被除数加入运算,因此讲最后得出的余数按得出顺序从晚到早排列就可以得出结果，我们写竖式的时候就是**从下到上**排列。

![进制转换1](/image//2/jzzh1.png)

**小数部分同理，其本质为通过，乘或除*r*来获得一个“多余的数”K0,并按一定的顺序排列，只不过整数除法得到的余数是目前最小的低位，小数乘法得到的是目前最高的高位**
![进制转换1](/image//2/jzzh2.png)

当然，我们心算快的人可以用一种**暴力拼凑**的方法，比如最常见的十进制到二进制转换。我们知道：

$$
2^1 = 2, \quad 2^2 = 4, \quad 2^3 = 8, \quad 2^4 = 16, \ldots, \quad 2^{10} = 1024
$$

> 这里建议玩一个小游戏 2048，快速上手。你也可以搜索在线进制转换工具来自己练习。

假设有一个数是 257，那么：

```math
(257)_{10} = (256 + 1)_{10} = (2^8 + 2^0)_{10} = (100000001)_{2}
```

**熟练应用是一个相当不错的应试技巧，但是时间够的话还是稳妥些。**

## 原码、反码、补码、移码
![机器数](/image//2/jqm.png)
计算机不可能按十进制为我们存储数据，我们说的原码、反码、补码、移码就是数据在计算机中存储的形式。

### 原码的表示与加法运算
#### 数字电路的知识补充
这里涉及到数字逻辑电路的知识，作为一个负责任的人我会帮大家先补习一下数电的知识。
在讲解之前我们返回第一章，我们知道逻辑元件的发展经历了**从电子管到晶体管再到集成电路**的发展历程，而我们也提到过一个叫做***封装***的概念，接下来我们通过一个游戏来具体了解这些逻辑电路是怎么一步步封装起来的。
```
这里用到的游戏叫做Truing complete（图灵完备）,可以自己在steam上买一个玩，经常打折，很便宜。
```
首先我们先了解一个东西，现代计算机主要使用CMOS（互补金属氧化物半导体）技术与TTL（晶体管-晶体管逻辑）技术，最常见的是CMOS，他们互有优劣，使用场景和优劣分析可以自行查阅，使用CMOS最大的原因是因为**省钱**。
**COMS**:
![COMS](/image//2/COMS.png)
**TTL**：
![TTL](/image//2/TTL.png)
他们共同的作用是：
- 当输入为高电平（1）时，NMOS导通（晶体管导通），输出为低电平（0）。
- 当输入为低电平（0）时，PMOS导通（晶体管截止），输出为高电平（1）。

而通过这个元件，我们就可以组建我们电脑中的基本元件。
****
以下是非门、与门、或门、与非门和或非门的真值表：

### 非门（NOT Gate）
| 输入 (A) | 输出 (Y) |
|----------|----------|
|    0     |    1     |
|    1     |    0     |

### 与门（AND Gate）
| 输入 (A) | 输入 (B) | 输出 (Y) |
|----------|----------|----------|
|    0     |    0     |    0     |
|    0     |    1     |    0     |
|    1     |    0     |    0     |
|    1     |    1     |    1     |

### 或门（OR Gate）
| 输入 (A) | 输入 (B) | 输出 (Y) |
|----------|----------|----------|
|    0     |    0     |    0     |
|    0     |    1     |    1     |
|    1     |    0     |    1     |
|    1     |    1     |    1     |

### 与非门（NAND Gate）
| 输入 (A) | 输入 (B) | 输出 (Y) |
|----------|----------|----------|
|    0     |    0     |    1     |
|    0     |    1     |    1     |
|    1     |    0     |    1     |
|    1     |    1     |    0     |

### 或非门（NOR Gate）
| 输入 (A) | 输入 (B) | 输出 (Y) |
|----------|----------|----------|
|    0     |    0     |    1     |
|    0     |    1     |    0     |
|    1     |    0     |    0     |
|    1     |    1     |    0     |

这些真值表展示了每种逻辑门在不同输入情况下的输出结果。
*****
我们发现CMOS的特性完美符合我们的非门的真值表，而在数字逻辑电路中我们采用一些特定的符号来表示这些门，本笔记主要用国外流行图形符号。
![逻辑门电路](/image/2/ljmdl.png)
```
现代计算机的具体实现可以参考知乎文章
1.2计算机组成原理-逻辑门 - Bytehub的文章 - 知乎
https://zhuanlan.zhihu.com/p/429544891
更详细的理解可可以参考
【【计算机科学速成课】[40集全/精校] - Crash Course Computer Science】 https://www.bilibili.com/video/BV1EW411u7th/?p=3&share_source=copy_web&vd_source=ac577b966f2e9f3eeaecc61d44a9ddd9
```
我们讲晶体管的实物抽象为这样一张图片(图片来源为计算机科学速成课)，此时一个单独的晶体管为**非门**。
他类似一个开关，**current**是电流，当输入为1时，电路打开，电流接地，所以输出是0，即**off**。反之电流通过，输出为**on**。

![Not Gate](/image/2/NotGate.png)

同样我们可以用两个晶体管**串联**起来组成**与门**

![And Gate](/image/2/AndGate.png)

类似地，我们可以通过**并联**的方式组成**或门**

![Or Gate](/image/2/OrGate.png)

现在我们将上面这三个门作一次封装，即变为上面提到的逻辑符号，将与门与非门串联起来可以得到**与非门**（就是与门前加了个小圆圈，很好懂对吧？）。

![Not And Gate](/image/2/NotAndGate.png)

事实上我们可以用**与非门**做基础得到所有的门，**Truing complete（图灵完备）** 这款游戏就是这么做的，我们来看一些游戏截图。
- 用与非门表示非门
  ![Or Gate](/image/2/TC1.png)
- 表示与门（操作有点像套娃，电路很有意思对吧）
  ![And Gate](/image/2/TC2.png)
- 用与非门表示或门
  ![Or Gate](/image/2/TC3.png)
我们还可以以此为基础做更多的操作！
比如**或非门**
![OrNot Gate](/image/2/TC4.png)
```
剩下的太过简单了，基本是几个门的相互组合，其实不难对吧。
```
我们再看最后一个**异或门**

![exclusive-OR gate](/image/2/TC5.png)
### 加法器的诞生
OK!我们现在复习（或学习）了一下基本的逻辑门电路，我们要探讨一下一位二进制加法是如何进行运算的。
我们不考虑进位的情况，2进制加法可以类比十进制加法，0+0=0，0+1=1，1+0=1，他们的结果都可以用一位二进制数来表示，问题是，1+1=10，最后一种情况多了一种位，因此我们结果需要多留一位来保留进位，其真值表如下。

包括进位（Carry）和结果（Sum）：

| 输入A | 输入B | 进位（Carry） | 结果（Sum） |
|-------|-------|---------------|-------------|
|   0   |   0   |       0       |      0      |
|   0   |   1   |       0       |      1      |
|   1   |   0   |       0       |      1      |
|   1   |   1   |       1       |      0      |

而这个结果在数字电路中非常简单，只要两个逻辑门元件就能表示，不考虑进位只需要进行一次异或运算，而进位仅在都为1时成立，需要一个异或门和一个与门。

![half-add unit](/image/2/TC6.png)
恭喜你！我们目前做出了一个**半加器**！它用来计算1位二进制的运算结果，我们不妨再多加一个输出，三个输出的情况下共有8种结果，半加器显然不够看。

以下是全加器（Full Adder）的真值表，包括两个输入位（A和B）、一个进位输入（Carry In，简称Cin）、一个进位输出（Carry Out，简称Cout）和一个和（Sum）：

| 输入A | 输入B | 进位输入 (Cin) | 进位输出 (Cout) | 和 (Sum) |
|-------|-------|----------------|-----------------|----------|
|   0   |   0   |       0        |        0        |     0    |
|   0   |   0   |       1        |        0        |     1    |
|   0   |   1   |       0        |        0        |     1    |
|   0   |   1   |       1        |        1        |     0    |
|   1   |   0   |       0        |        0        |     1    |
|   1   |   0   |       1        |        1        |     0    |
|   1   |   1   |       0        |        1        |     0    |
|   1   |   1   |       1        |        1        |     1    |

现在是不是开始头疼了？没关系，其实只要额外在半加器的基础上继续做异或运算，并保证进位在有两个或三个输出为1时成立就好啦。

![full adder](/image/2/TC7.png)
恭喜你做出了有三个输出的**全加器**！
现在线路已经开始复杂了，我们对全加器做**一次封装**，用下面这个符号表示全加器。
![full adder](/image/2/fulladder.png)。
事实上计算机不可能只用三个输入只进行这么低等的加法，我们常用的是**八位加法器**，他的输入有**两个八位输入和来自其他加法器的一位进位**，想想头就大了！但是我们已经对全加器做了封装，其实只需要对两个八位输入拆分成8个1位的输入并于进位输入进行**总共8次加法**，将结果合并起来就好了。
![full adder](/image/2/8bitfulladder.png)。
**我们应该有听过0或1对应计算机内部一个开关的闭合或者高低电平，所以拆分和合并很简单，只要一个分线器和集线器把内部的电路分开或集合就好了，集线器和分线器这里不是重点。**
****

### 原码运算与其缺陷

我们成功实现了一个**8位加法器**，用于处理**无符号8位二进制整数**。输入范围是0到255，输出范围考虑到进位是0到510（9位输出不可能都是1）。

**原码**就是普通的二进制代码。根据原码加法的原理，我们可以很轻松地制造出加法器。

#### 原码的缺陷

有**无符号整数**，自然也有**有符号整数**，即我们所说的**正数和负数**。数字部分很好表示，但**正负号**如何表示呢？

很简单，正负号同样只有两种情况，我们可以用0和1代替，**0表示正数，1表示负数**。按之前的8位表示，我们可以匀出一位作为**符号位**，剩余的七位则是**数值位**。这样表示的范围是：11111111 ~ 01111111，即-127到+127。

这时问题出现了：原码表示中出现了**+0**和**-0**两种情况！如果我们按照之前的加法器设计对有符号数进行加减，会出现以下问题：

1. **正数加负数时，由于符号位相加为1，导致结果是负数**；
2. **数值位相加时的进位会影响到符号位，数值位溢出会进位到符号位，而不是加法器的进位上，导致各种复杂的后果**。

### 反码的诞生
反码的诞生与计算机处理负数的需求密切相关。在计算机科学中，反码是一种用于表示有符号整数的二进制编码方法。以下是反码的由来和作用：

为了克服原码的局限性，反码（Ones' Complement）被引入。反码的表示方法是**将正数不变，负数除符号位的每一位取反（0变1，1变0）**。例如：
- 正数：+5 的二进制表示为 00000101
- 负数：-5 的反码表示为 11111010
#### 反码的优点
通过之前的了解我们发现**原码无法做减法**，且**相反数相加无法为0**，反码的核心就是为了解决这几个问题。
**反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那干脆用一个正数按位取反来表示负数。**
再试着用反码的方式解决一下原码的问题:
```
0001+1110=1111，1+(-1)=-0；
1110+1100=1010，(-1)+(-3)=-5。
```
互为相反数相加等于0，虽然的到的结果是1111也就是-0。但是两个负数相加却出错了。

反码的特点：

1.在反码表示中，用符号位表示数值的正负，形式与原码表示相同，即0为正；1为负。

2.在反码表示中，数值0有两种表示方法。

3.反码的表示范围与原码的表示范围相同。

**反码表示在计算机中往往作为数码变换的中间环节。**

### 补码
为了解决原反码加减运算的问题，我们引入了补码的概念。
**补码：正数的补码等于它的原码；负数的补码等于反码+1（注意这只是计算方法而不是定义）。**
#### 补码的原理
我们可以用**十二小时制的时钟**来类比，这个时钟只有一个时针，他默认停在0点上，现在你要表示三点。

你会有两种方法来表示三点这个值：
- 正向移动：如果我们从0点顺时针移动3个小时，时钟指向3点，这表示+3。
- 反向移动：如果我们从0点逆时针移动9个小时，时钟也会指向3点，这表示-9。

类比发现，他们抛开符号位相加的结果正好为12，用**二十四小时制**就可以很好的解释这一切，为什么顺时针3h和逆时针9h相同呢？

在现实中，这两个操作表示的时间本质上不是一天，一个是昨天下午3点，一个是今天凌晨3点。

**但在硬件层面中，这两个是一样的。**
以此类推，我们发现在这个时钟上，任意做一个k小时的变化，+k与-（12-k）的后果是一样的。

**所以n小时制，k既可以代表+k，也可以代表-(n - k)。**
扩展到补码概念，对于一个8位二进制数（范围0到255），可以看作是一个256小时制的时钟。例如：
```
+3表示为00000011
-3的补码表示为11111101（即256 - 3 = 253）
```
通过补码，我们将**减法转换为加这个数的负数**，简化计算，同时也代表**补码的符号位可以加入运算啦！**。
以后我们做算法题遇到二进制补码转换为十进制的时候就不用再分正负两种情况敲代码了。直接使用公式：。


$$
\sum_{i=1}^{w} x_i^2 \cdot 2^i - x_{w-1}^2 \cdot 2^{w-1}
$$


最后附上一段C语言将二进制字符串转换为十进制数的代码：

```c
int BinaryToDecimal(const char *binaryString) {
    int index = 1;
    int result = '0' - binaryString[index];
    while (binaryString[index] != '\0') {
        result = (result << 1) + (binaryString[index] - '0');
        index++;
    }
    return result;
}
```
总结：先计算出数值位，再根据符号位确定是否减去符号位的权值。

#### 计算技巧
**正数原反补码都相同**
负数原码补码快速互转：从右往左找到第一个1之后的**数值位**全部取反。
比如：
- ( x = 100001/10 )（即十进制原码的-6）
- x的补码为 111110/10
**这样计算的原理在于二进制的特殊性，补码 = 反码+1，+1后从右开始一旦反码连续为1（即反码为0）会全变为0直到反码该位为0（即原码为1）为止，单纯的步骤简化。**
- 计算反码
反码：( 11111001 )
- 反码加1
补码：( 11111001 + 1 = 11111010 )
****
这样的技巧也可以用在**正负补码间的转换**上，实质是补码转换为原码并将符号位取反重复上述操作的结果，区别是从右往左找到第一个1之后的位**全部取反**（包括符号位）比如：
- ( x = 11111010)（即补码十进制的-6）
- ( -x = 00000110)（即补码十进制的6）
![转换](/image/2/convert.png)
### 原反补码的特性对比
![特性对比](/image/2/txdb.png)

### 移码
移码没什么好讲的，它是在**补码的基础上将符号位取反**，目的是为了**比大小**。
![对比](/image/2/ym.png)

