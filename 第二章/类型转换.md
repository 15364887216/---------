# C语言中的强制类型转换
1.数据类型介绍
在进行相关的讲解之前，我们可以一起回忆一下数据的基本内置类型。
```c
char        //字符数据类型
short       //短整型
int         //整形
long        //长整型
long long   //更长的整形
float       //单精度浮点数
double      //双精度浮点数
```
而在此基础上继续细分：

整形家族
```c
char
 unsigned char
 signed char
short
 unsigned short [int]
 signed short [int]
int
 unsigned int
 signed int
long
 unsigned long [int]
 signed long [int]
 ```
浮点数家族
```c
float
double
```
构造类型
```c
数组类型
结构体类型 struct
枚举类型 enum
联合类型 union
```
指针类型
```c
int *pi;
char *pc;
float* pf;
void* pv;
```
空类型
```
空类型即void函数，通常应用于函数的返回类型、函数的参数、指针类型。而相关的空指针void *，从某种程度上运用更加广泛。相当于任何类型的指针都可以直接赋值给void *，从而无需进行强制类型转换。当然并不意味着，void *也可以无需强制类型转换地赋给其它类型的指针。因为"无类型"可以包容"有类型"，而"有类型"则不能包容"无类型"。
```

## 整数强制类型转换
前面说过计算机中为了运算等各种原因，计算机中用补码存储数据，前面已经说过了。
```
为什么呢？
因为在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
```
整数类型的根本区别有两个:
- 字节数
- 有无符号位(即C语言中有无**unsigned**)

C语言中常见整数数据类型的字节数及其最小值和最大值：

1. **`char`**
   - 字节数：1
   - 最小值：-128
   - 最大值：127

2. **`unsigned char`**
   - 字节数：1
   - 最小值：0
   - 最大值：255

3. **`short`**
   - 字节数：2
   - 最小值：-32,768
   - 最大值：32,767

4. **`unsigned short`**
   - 字节数：2
   - 最小值：0
   - 最大值：65,535

5. **`int`**
   - 字节数：4
   - 最小值：-2,147,483,648
   - 最大值：2,147,483,647

6. **`unsigned int`**
   - 字节数：4
   - 最小值：0
   - 最大值：4,294,967,295

7. **`long`**
   - 字节数：4（在32位系统）或8（在64位系统）
   - 最小值：-2,147,483,648（32位）或 -9,223,372,036,854,775,808（64位）
   - 最大值：2,147,483,647（32位）或 9,223,372,036,854,775,807（64位）

8. **`unsigned long`**
   - 字节数：4（在32位系统）或8（在64位系统）
   - 最小值：0
   - 最大值：4,294,967,295（32位）或 18,446,744,073,709,551,615（64位）

9. **`long long`**
   - 字节数：8
   - 最小值：-9,223,372,036,854,775,808
   - 最大值：9,223,372,036,854,775,807

10. **`unsigned long long`**
    - 字节数：8
    - 最小值：0
    - 最大值：18,446,744,073,709,551,615

这些数据类型的字节数和取值范围可能会因编译器和系统架构的不同而有所变化：
- 比如在32位系统中，int和long都是4个字节
- 为了区别32/64位系统的差别，出现了int_32类型和int_64类型，分别是4个字节，即4B，和8个字节，即8B
```
32位(即4个字节)和64位（即8个字节）是指计算机系统中CPU（中央处理器）一次处理数据的宽度，即CPU内部寄存器、指令集、数据总线以及内存地址总线等能够同时处理的数据位数。
```
整数类型间转换的本质就是字节数和符号位的变化，**无符号数变为有符号数只需要最高位作为符号位就行了，反之一样**，硬件方面不会有变化。
**字节**变化的方式是**短变长符号拓展，长变短高位截断**。
![类型转换](/image/2/lxzh.png)
让我们通过具体的例子来理解整数类型间转换的本质：

### 1. 无符号数变为有符号数
假设我们有一个8位的无符号整数（`unsigned char`），值为`255`（二进制：`11111111`）。

- **无符号数255**：`11111111`
- **转换为有符号数**：最高位作为符号位，结果是`-1`（在补码表示法中，`11111111`表示`-1`）。

### 2. 短变长符号拓展
假设我们有一个8位的有符号整数（`signed char`），值为`-1`（二进制：`11111111`）。

- **8位有符号数-1**：`11111111`
- **转换为32位有符号数**：符号扩展，高位填充符号位，结果是`-1`（`11111111 11111111 11111111 11111111`）。

### 3. 长变短高位截断
假设我们有一个32位的无符号整数（`unsigned int`），值为`4294967295`（二进制：`11111111 11111111 11111111 11111111`）。

- **32位无符号数4294967295**：`11111111 11111111 11111111 11111111`
- **转换为8位无符号数**：高位截断，只保留低8位，结果是`255`（`11111111`）。

# 浮点数的存储
使用**IEEE 754**标准表示，分为单精度（32位）和双精度（64位）。浮点数由**符号位、指数位和尾数位**组成。

IEEE 754标准采用类似于科学计数法的方式。浮点数的表示公式为：

$$ V = (-1)^s \times M \times 2^E $$

其中：
- \( s \) 是符号位，当 \( s = 0 \) 时，表示正数；当 \( s = 1 \) 时，表示负数。
- \( M \) 是有效数字（尾数），对于单精度浮点数，范围是 \( 1 \leq M < 2 \)。
- \( E \) 是指数位，表示为偏移量形式（即实际指数值加上一个偏移量）。

例如，对于单精度浮点数（32位）：
- 符号位 \( s \) 占1位。
- 指数位 \( E \) 占8位，偏移量为127。
- 尾数 \( M \) 占23位。

反过来我们也可以理解为什么符号位要用0表示正数，1表示负数，因为符号位n表示的是（-1）^n^ 。

举例来说：
十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2^2^ 。

那么，按照上面V的格式，可以得出S=0，M=1.01，E=2。

十进制的-5.0，写成二进制是 -101.0 ，相当于 -1.01×2^2^ 。那么，S=1，M=1.01，E=2。
![类型转换](/image/2/IEEE.png)
现在要讨论两个问题：
- 为什么阶码要用**移码**表示：
  
  我们说过移码是补码的符号位取反得到的，这样符号位正数为1，负数为0，**正数直观看出恒大于负数**。
因为补码表示-128~127，即00000000 ~11111111.
这样可以直观地***比大小和简化运算**。

- 为什么尾数要用**原码**表示：
  我们明明之前在疯狂解决硬件中的各种问题才选择了补码这种形式，为什么尾数要用原码？其实很简单，因为**直观**。尾数与整数表示时不一样，不需要参与什么复杂的加减运算，我们计算补码的值也需要转换成原码才能算，既然不需要参加运算我们干脆直接用原码。

**M**默认是1.XXXX，没必要专门花一位存储必然的1，因此**最高位1是被隐藏掉的**，如果我们硬件中实际存储比如23位，他的有效位数应该是23+1，即24位。

在IEEE 754标准中，阶码全0和全1有特殊用途：

1. **阶码全0**：
   - **尾数全0**：表示正零或负零，取决于符号位。
   - **尾数不全0**：表示非规范化数（subnormal number），用于表示非常小的数值。实际值为：$$(-1)^s \times 0.M \times 2^{-126}$$。

2. **阶码全1**：
   - **尾数全0**：表示正无穷大或负无穷大，取决于符号位。
   - **尾数不全0**：表示NaN（Not a Number），用于表示无效的数值，如计算中出现的未定义结果³⁴.

这些特殊用途帮助处理极端情况和异常值，使浮点数运算更加稳定和可靠。
# 浮点数的运算
浮点数的加减运算可以分为以下五个步骤：

1. **对阶**：将两个浮点数的阶码对齐。将指数**较小**的数的尾数右移，使得两个数的阶码相同。```尾数本质上是一个定点小数，右移只需要做算术右移就好，更简单。左移会增加小数点前的有效位，会很难。```
2. **尾数加减**：对齐后，进行尾数的加减运算。
3. **规格化**：调整结果，使其符合浮点数的规格化表示（即尾数的最高位为1）。比如$0.95\times2^{12}$要变为$9.5\times2^{11}$，即**左规**；比如$95.12\times2^{12}$要变为$9.512\times2^{13}$，即**右规**；
4. **舍入**：根据需要舍入尾数，以保持精度。
5. **溢出判断**：检查结果是否溢出或下溢，并进行相应处理。
![浮点数加减](/image//2/float.png)

### 示例
假设我们要计算 \(9.85211 \times 10^{12} + 9.96007 \times 10^{10}\)：

1. **对阶**：将 \(9.96007 \times 10^{10}\) 的阶码调整为 \(10^{12}\)，即 \(0.0996007 \times 10^{12}\)。
2. **尾数加减**：\(9.85211 + 0.0996007 = 9.9517107\)。
3. **规格化**：结果已经是规格化形式。
4. **舍入**：根据需要舍入尾数。
5. **溢出判断**：检查是否溢出或下溢。

最终结果为 \(9.9517107 \times 10^{12}\)。

让我们通过二进制表示来详细说明浮点数的加减运算过程(**考试不会直接用IEEE754标准**)。
![浮点数运算](/image/2/float1.png)
注意这里阶码和尾数都是补码，尾数作为定点小数在这里无法表示大于1(IEEE中的1是隐藏的)的数，即0.XXXX。图中题目在尾数加减时候发生了溢出，由于是双符号位，可以在规格化阶段用右规的方式解决，此时没有发生舍入，最后判断阶码是否符号位相同（双符号位）得出也没有溢出，得出结果。
![浮点数运算](/image/2/float2.png)
我们也会遇到需要舍入的问题，比如图中给的例子，但是0舍1入碰到尾数全为1等情况会导致一直右规。恒置1会导致尾数数值的变化。有些计算机会将尾数摘出去用更大的位数存起来之后经过舍入再拼回去。

## 浮点数类型转换
![浮点数运算](/image/2/float3.png)
float-->doubt之间与整形一样，只会有字节的变化
关键在于浮点数和整形的变化，int 32位的有效数字显然转换为float 24位有效数字时可能产生精度损失。
**示例**
假设有一个 int 类型的数 `16777217`，其二进制表示为 `100000000000000000000001`（24位）。

当转换为 float 类型时，由于尾数位只有23位，二进制表示将变为 `10000000000000000000000`（23位），即 `16777216`。
因此，`16777217`转换为 float 后变为 `16777216`，发生了精度损失。

float ->int的情况我们知道float的表示范围比int大得多还能表示小数，所以转换还可能发生溢出,int对于float的精度损失的处理是**直接裁掉小数部分**。

以下是一个示例来说明这种情况：

**示例**
假设我们有一个 `float` 类型的数值 `3.14e10`，即 \(3.14 \times 10^{10}\)。

1. **浮点数表示**：
   - `3.14e10` 在 `float` 类型中表示为 $3.14 \times 10^{10}$，其二进制表示可能是 $1.11001100110011001100110 \times 2^{33}$（近似值）。

2. **转换为 `int`**：
   - 当将这个 `float` 类型的数值转换为 `int` 类型时，数值部分会被截断，只保留整数部分。
   - 由于 `3.14e10` 超过了 `int` 类型的表示范围（假设 `int` 类型是32位的，最大值为 `2,147,483,647`），会发生溢出。

3. **结果**：
   - 转换后的结果可能是一个错误的值，或者在某些编程语言中会抛出溢出异常。
   - 即使数值在 `int` 类型的范围内，转换过程中也会丢失小数部分的精度。例如，`3.14` 转换为 `int` 后变为 `3`，小数部分 `.14` 被舍去。

**代码示例**
以下是一个简单的C++代码示例，展示了 `float` 到 `int` 转换时的溢出和精度损失：

```cpp
#include <iostream>
using namespace std;

int main() {
    float largeFloat = 3.14e10;
    int convertedInt = static_cast<int>(largeFloat);

    cout << "Original float: " << largeFloat << endl;
    cout << "Converted int: " << convertedInt << endl;

    return 0;
}
```

### 输出
```
Original float: 3.14e+10
Converted int: -2147483648  // 可能的溢出结果
```

在这个例子中，`3.14e10` 转换为 `int` 后，由于超出了 `int` 的表示范围，结果可能是一个负数（溢出）。

# 数据的存储和排列
![](/image/2/dxd.png)
大小端（Endianess）是指计算机系统在存储多字节数据时，字节的排列顺序。主要有两种方式：大端（Big Endian）和小端（Little Endian）。

1. **大端模式（Big Endian）**：
   - 高位字节存放在低地址，低位字节存放在高地址。
   - 例如，数值 `0x12345678` 在大端模式下的存储顺序为：
     ```
     地址:  0x00  0x01  0x02  0x03
     数据:  0x12  0x34  0x56  0x78
     ```

2. **小端模式（Little Endian）**：
   - 低位字节存放在低地址，高位字节存放在高地址。
   - 例如，数值 `0x12345678` 在小端模式下的存储顺序为：
     ```
     地址:  0x00  0x01  0x02  0x03
     数据:  0x78  0x56  0x34  0x12
     ```

大端模式更符合人类的阅读习惯，而小端模式则更符合计算机处理数据的方式。
```
大小端很好理解，我们人类读的时候是从左往右（高位到低位），运算时会从右往左（低位到高位），或者说从个位开始算。计算机没有把数字读出声的需求，小端模式更适合运算。
```
****
![](/image/2/bjdq.png)
边界对齐（Boundary Alignment）是指在计算机系统中，数据在内存中的存储地址需要满足特定的对齐要求。这样做的目的是提高内存访问的效率。以下是边界对齐的几个关键点：

1. **对齐规则**：
   - 数据类型的大小决定了其对齐的边界。例如，4字节的整数（int）需要4字节对齐，即其起始地址必须是4的倍数。
   - 2字节的短整数（short）需要2字节对齐，8字节的双精度浮点数（double）需要8字节对齐¹²。

2. **提高访问效率**：
   - 对齐可以减少处理器访问内存时的额外操作。未对齐的数据可能需要多次内存访问才能读取完整数据，而对齐的数据通常只需一次访问。

3. **内存填充（Padding）**：
   - 为了满足对齐要求，编译器可能会在数据之间插入额外的字节。这些额外的字节称为填充字节（padding bytes），它们不存储实际数据，但确保后续数据的对齐⁴。

4. **示例**：
   - 假设有一个结构体包含一个char（1字节）、一个int（4字节）和一个short（2字节）。为了对齐，编译器可能会在char和int之间插入3个填充字节，使得int的起始地址是4的倍数。

```c
struct Example {
    char c;    // 1 byte
    // 3 bytes padding
    int i;     // 4 bytes
    short s;   // 2 bytes
};
```