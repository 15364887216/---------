# C语言中的强制类型转换
1.数据类型介绍
在进行相关的讲解之前，我们可以一起回忆一下数据的基本内置类型。
```c
char        //字符数据类型
short       //短整型
int         //整形
long        //长整型
long long   //更长的整形
float       //单精度浮点数
double      //双精度浮点数
```
而在此基础上继续细分：

整形家族
```c
char
 unsigned char
 signed char
short
 unsigned short [int]
 signed short [int]
int
 unsigned int
 signed int
long
 unsigned long [int]
 signed long [int]
 ```
浮点数家族
```c
float
double
```
构造类型
```c
数组类型
结构体类型 struct
枚举类型 enum
联合类型 union
```
指针类型
```c
int *pi;
char *pc;
float* pf;
void* pv;
```
空类型
```
空类型即void函数，通常应用于函数的返回类型、函数的参数、指针类型。而相关的空指针void *，从某种程度上运用更加广泛。相当于任何类型的指针都可以直接赋值给void *，从而无需进行强制类型转换。当然并不意味着，void *也可以无需强制类型转换地赋给其它类型的指针。因为"无类型"可以包容"有类型"，而"有类型"则不能包容"无类型"。
```

## 整数强制类型转换
前面说过计算机中为了运算等各种原因，计算机中用补码存储数据，前面已经说过了。
```
为什么呢？
因为在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
```
整数类型的根本区别有两个:
- 字节数
- 有无符号位(即C语言中有无**unsigned**)

C语言中常见整数数据类型的字节数及其最小值和最大值：

1. **`char`**
   - 字节数：1
   - 最小值：-128
   - 最大值：127

2. **`unsigned char`**
   - 字节数：1
   - 最小值：0
   - 最大值：255

3. **`short`**
   - 字节数：2
   - 最小值：-32,768
   - 最大值：32,767

4. **`unsigned short`**
   - 字节数：2
   - 最小值：0
   - 最大值：65,535

5. **`int`**
   - 字节数：4
   - 最小值：-2,147,483,648
   - 最大值：2,147,483,647

6. **`unsigned int`**
   - 字节数：4
   - 最小值：0
   - 最大值：4,294,967,295

7. **`long`**
   - 字节数：4（在32位系统）或8（在64位系统）
   - 最小值：-2,147,483,648（32位）或 -9,223,372,036,854,775,808（64位）
   - 最大值：2,147,483,647（32位）或 9,223,372,036,854,775,807（64位）

8. **`unsigned long`**
   - 字节数：4（在32位系统）或8（在64位系统）
   - 最小值：0
   - 最大值：4,294,967,295（32位）或 18,446,744,073,709,551,615（64位）

9. **`long long`**
   - 字节数：8
   - 最小值：-9,223,372,036,854,775,808
   - 最大值：9,223,372,036,854,775,807

10. **`unsigned long long`**
    - 字节数：8
    - 最小值：0
    - 最大值：18,446,744,073,709,551,615

这些数据类型的字节数和取值范围可能会因编译器和系统架构的不同而有所变化：
- 比如在32位系统中，int和long都是4个字节
- 为了区别32/64位系统的差别，出现了int_32类型和int_64类型，分别是4个字节，即4B，和8个字节，即8B
```
32位(即4个字节)和64位（即8个字节）是指计算机系统中CPU（中央处理器）一次处理数据的宽度，即CPU内部寄存器、指令集、数据总线以及内存地址总线等能够同时处理的数据位数。
```
整数类型间转换的本质就是字节数和符号位的变化，**无符号数变为有符号数只需要最高位作为符号位就行了，反之一样**，硬件方面不会有变化。
**字节**变化的方式是**短变长符号拓展，长变短高位截断**。
![类型转换](/image/2/lxzh.png)
让我们通过具体的例子来理解整数类型间转换的本质：

### 1. 无符号数变为有符号数
假设我们有一个8位的无符号整数（`unsigned char`），值为`255`（二进制：`11111111`）。

- **无符号数255**：`11111111`
- **转换为有符号数**：最高位作为符号位，结果是`-1`（在补码表示法中，`11111111`表示`-1`）。

### 2. 短变长符号拓展
假设我们有一个8位的有符号整数（`signed char`），值为`-1`（二进制：`11111111`）。

- **8位有符号数-1**：`11111111`
- **转换为32位有符号数**：符号扩展，高位填充符号位，结果是`-1`（`11111111 11111111 11111111 11111111`）。

### 3. 长变短高位截断
假设我们有一个32位的无符号整数（`unsigned int`），值为`4294967295`（二进制：`11111111 11111111 11111111 11111111`）。

- **32位无符号数4294967295**：`11111111 11111111 11111111 11111111`
- **转换为8位无符号数**：高位截断，只保留低8位，结果是`255`（`11111111`）。

## 浮点数的存储
使用**IEEE 754**标准表示，分为单精度（32位）和双精度（64位）。浮点数由**符号位、指数位和尾数位**组成。

IEEE 754标准采用类似于科学计数法的方式。浮点数的表示公式为：

$$ V = (-1)^s \times M \times 2^E $$

其中：
- \( s \) 是符号位，当 \( s = 0 \) 时，表示正数；当 \( s = 1 \) 时，表示负数。
- \( M \) 是有效数字（尾数），对于单精度浮点数，范围是 \( 1 \leq M < 2 \)。
- \( E \) 是指数位，表示为偏移量形式（即实际指数值加上一个偏移量）。

例如，对于单精度浮点数（32位）：
- 符号位 \( s \) 占1位。
- 指数位 \( E \) 占8位，偏移量为127。
- 尾数 \( M \) 占23位。

反过来我们也可以理解为什么符号位要用0表示正数，1表示负数，因为符号位n表示的是（-1）^n^ 。

举例来说：
十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2^2^ 。

那么，按照上面V的格式，可以得出S=0，M=1.01，E=2。

十进制的-5.0，写成二进制是 -101.0 ，相当于 -1.01×2^2^ 。那么，S=1，M=1.01，E=2。
![类型转换](/image/2/IEEE.png)
现在要讨论两个问题：
- 为什么阶码要用**移码**表示：
  
  我们说过移码是补码的符号位取反得到的，这样符号位正数为1，负数为0，**正数直观看出恒大于负数**。
因为补码表示-128~127，即00000000 ~11111111.
这样可以直观地***比大小和简化运算**。

- 为什么尾数要用**原码**表示：
  我们明明之前在疯狂解决硬件中的各种问题才选择了补码这种形式，为什么尾数要用原码？其实很简单，因为**直观**。尾数与整数表示时不一样，不需要参与什么复杂的加减运算，我们计算补码的值也需要转换成原码才能算，既然不需要参加运算我们干脆直接用原码。

**M**默认是1.XXXX，没必要专门花一位存储必然的1，因此**最高位1是被隐藏掉的**，如果我们硬件中实际存储比如23位，他的有效位数应该是23+1，即24位。

在IEEE 754标准中，阶码全0和全1有特殊用途：

1. **阶码全0**：
   - **尾数全0**：表示正零或负零，取决于符号位。
   - **尾数不全0**：表示非规范化数（subnormal number），用于表示非常小的数值。实际值为：$$(-1)^s \times 0.M \times 2^{-126}$$。

2. **阶码全1**：
   - **尾数全0**：表示正无穷大或负无穷大，取决于符号位。
   - **尾数不全0**：表示NaN（Not a Number），用于表示无效的数值，如计算中出现的未定义结果³⁴.

这些特殊用途帮助处理极端情况和异常值，使浮点数运算更加稳定和可靠。
## 浮点数的运算
浮点数的加减运算可以分为以下五个步骤：

1. **对阶**：将两个浮点数的阶码对齐。将指数**较小**的数的尾数右移，使得两个数的阶码相同。```尾数本质上是一个定点小数，右移只需要做算术右移就好，更简单。左移会增加小数点前的有效位，会很难。```
2. **尾数加减**：对齐后，进行尾数的加减运算。
3. **规格化**：调整结果，使其符合浮点数的规格化表示（即尾数的最高位为1）。比如$0.95\times2^{12}$要变为$9.5\times2^{11}$，即**左规**；比如$95.12\times2^{12}$要变为$9.512\times2^{13}$，即**右规**；
4. **舍入**：根据需要舍入尾数，以保持精度。
5. **溢出判断**：检查结果是否溢出或下溢，并进行相应处理。
![浮点数加减](/image//2/float.png)

### 示例
假设我们要计算 \(9.85211 \times 10^{12} + 9.96007 \times 10^{10}\)：

1. **对阶**：将 \(9.96007 \times 10^{10}\) 的阶码调整为 \(10^{12}\)，即 \(0.0996007 \times 10^{12}\)。
2. **尾数加减**：\(9.85211 + 0.0996007 = 9.9517107\)。
3. **规格化**：结果已经是规格化形式。
4. **舍入**：根据需要舍入尾数。
5. **溢出判断**：检查是否溢出或下溢。

最终结果为 \(9.9517107 \times 10^{12}\)。

让我们通过二进制表示来详细说明浮点数的加减运算过程(**考试不会直接用IEEE754标准**)。
![浮点数运算](/image/2/float1.png)
注意这里阶码和尾数都是补码，尾数作为定点小数在这里无法表示大于1(IEEE中的1是隐藏的)的数，即0.XXXX。图中题目在尾数加减时候发生了溢出，由于是双符号位，可以在规格化阶段用右规的方式解决，此时没有发生舍入，最后也没有溢出，得出结果。