# 定点小数
这里我们速过，不是什么很难的东西。
定点小数与定点整数类似，但是没有移码表示。
![定点小数](/image/2/new1.png)
定点小数通常不使用移码表示，主要原因如下：

1. **移码的设计初衷**：移码（Excess-K）主要用于表示整数，特别是在浮点数的阶码中。它通过将补码的符号位取反来实现，这样可以方便地比较大小。

2. **表示范围和精度**：定点小数的表示范围通常在-1到1之间，而移码的表示范围是基于整数的，这会导致表示范围和精度不匹配。

3. **硬件实现复杂性**：使用移码表示定点小数会增加硬件实现的复杂性，因为需要额外的电路来处理符号位和小数点的位置。

4. **标准化和应用背景**：在计算机体系结构中，移码主要用于浮点数的阶码，而定点小数更多使用原码、反码和补码来表示，这些方法在处理小数时更为直接和高效。

小数部分和整数部分一样都用 **2^n^** 来表示，第一位小数是 **2^-1^**，以此类推。
## 定点小数原反补码的转换
同整数
![定点小数](/image/2/new2.png)
加减法运算在这里也适用
![定点小数](/image/2/new3.png)
当然我们可以再复习一下，做加减法的时候，正数原反补码不变，减法转换为加法：在补码表示中，**减去一个数等同于加上这个数的补码**，这里我们可能让教科书上的这句话哄了！我们可以理解为，**减去一个数等同于加上这个数的负数**，而硬件处理这个操作（即正负补码转化）的步骤与原补码转换的操作类似，即**全部位取反+1**.(别忘了符号位也参与运算！)
![定点小数](/image/2/new4.png)

## 定点小数与定点整数的区别
唯一的区别是**位数拓展时，拓展位数不一样。**这个很好理解，**N**为正整数，**2^N^** 拓展为 **2^N+1^**，向前填充，小数部分 **2^-N^** 拓展为 **2^-N-1^**，向后填充
![定点小数](/image/2/new5.png)

# 算术逻辑单元
前面已经说过基本逻辑单元和数电的一些相关知识了。我们重点看一下ALU（算术逻辑单元）
![ALU](/image/2/ALU.png)
我们看到图中有很多术语：
这些术语都是计算机运算器中的重要组成部分，每个部分都有特定的功能：

1. **MQ（Multiplier-Quotient Register，乘商寄存器）**：在乘法运算中存放乘数，在除法运算中存放商¹。由于乘法和除法的结果可能会超出一个寄存器的范围，MQ用于存储这些结果的高位或低位部分。

2. **ACC（Accumulator，累加器）**：用于存储运算的中间结果和最终结果²。在加法和减法运算中，ACC存储被加数或被减数，并保存运算结果。在乘法和除法运算中，ACC也会参与存储部分结果。

3. **X（操作寄存器）**：用于存储操作数¹。在执行运算时，操作数会被加载到X寄存器中，供ALU使用。

4. **PSW（Program Status Word，程序状态字）**：存储当前运算的状态信息，如运算结果的符号、零标志、进位标志和溢出标志³。这些标志用于控制程序的执行流程和错误处理。

5. **ALU（Arithmetic Logic Unit，算术逻辑单元）**：运算器的核心部分，负责执行所有的算术运算（如加、减、乘、除）和逻辑运算（如与、或、非、异或）²。ALU接收来自寄存器的数据，执行运算，并将结果返回到寄存器中。

这些组件共同工作，使得计算机能够高效地执行各种算术和逻辑运算。

¹: [运算器的基本组成及操作过程 - CSDN博客](https://blog.csdn.net/weixin_44915226/article/details/123232816)
²: [计算机硬件组成原理名词解释 - 知乎](https://zhuanlan.zhihu.com/p/356538531)
³: [定点运算器的基本结构(图解篇) - 电子发烧友网](https://www.elecfans.com/baike/computer/taishiji/20100413215658.html)

目前我们只关注**ALU**，还记得前面我们为了理解加法做了一个全加器吗？当然更专业一点是**并行进位加法器**。全加器已经可以做一些运算了，比如添加一些电路可以做减法，但**ALU**不满足于**算术运算（加减乘除等）**，还有**逻辑运算（与或非等）**，还有**辅助功能（移位等）**，其实在加法器上做一个拓展就好，来看一个简陋的**ALU**（不满足上面说的全部运算，依旧用图灵完备做例子。）
![ALU](/image/2/ALU1.png)
根据电路细节我们来看一下它具体有些什么？
- **操作码**：通过并行总线输入，它向 ALU 传递选择的操作的信息，该操作选择码是对 ALU 要执行的算术或逻辑运算的枚举。
- **数据**：一个基本的 ALU 具有三个并行的数据总线，包括两个输入操作数（输入1、输入2）和结果输出（Output）。

在我图上可以注意到，我们通过一个3位解码器来实现6种运算，加，减，与，或，非，异或。当操作码表示相应的操作时通过解码器打开相应的开关并输出两数进行运算的结果。当然真实情况会更复杂一些。比如我们实验中会接触到的74181（上面的图有），可能需要处理进位，也需要向其他部位发送一些命令信号。
![add](/image/2/add.png)

# 标志位的生成
![add](/image/2/add1.png)
 其中关于加减法的部分可以抽象为上图，看图即可。
 我们注意到图中除了结果的输出线多了四条指令,他们就是**标志位**.

标志位（flag bit）在计算机系统中起着非常重要的作用，主要用于指示运算结果的特定状态。以下是一些常见的标志位及其作用：

1. **溢出标志位（OF, Overflow Flag）**：用于指示有符号数运算是否发生溢出。如果运算结果超出了表示范围，OF会被置为1。

2. **符号标志位（SF, Sign Flag）**：用于指示运算结果的符号。如果结果为负数，SF会被置为1；如果为正数，SF会被置为0。

3. **零标志位（ZF, Zero Flag）**：用于指示运算结果是否为零。如果结果为零，ZF会被置为1。

4. **进位标志位（CF, Carry Flag）**：用于指示无符号数运算是否发生进位或借位。如果发生进位或借位，CF会被置为1。
![标志位](/image/2/bzw.png)
这些标志位在处理器的状态寄存器中保存，帮助处理器在执行指令时做出正确的决策。例如，在条件跳转指令中，处理器会根据标志位的状态决定是否跳转到指定的代码位置。

这里我们需要重点说一下溢出,我们知道加减运算最后都会变为补码运算,符号位也同时参与运算,而它会产生的一种特殊情况就是**溢出**.
## 溢出概念与判别方法
**什么是溢出？**
溢出是指运算结果超过了数的表示范围。通常，称大于机器所能表示的最大正数为上溢，小于机器所能表示的最小负数为下溢。

计算机使用固定长度的机器数来表示数的，其所能表示的范围是有限的。运算结果超过了这个范围就溢出了。

**什么情况下会溢出？**
两正数相加（或正数减负数）可能产生上溢；两负数相加（或负数减正数）可能产生下溢。

**补码定点数加/减运算溢出判断**
补码减法也是用加法器实现的，因此，补码加/减运算最后都可以转化为A补+B补。

加法溢出的情况是：正数+正数可能。产生溢出（上溢），负数+负数可能产生溢出（溢出）

（1）采用一位符号位

A补，B补的符号相同，结果与它们不同，则结果溢出。

解释：补码加法时，符号位与数值位一起参加运算，如果结果超过正数范围（如0111，超过这个最大正数，机器数就往1000、1001...这个方向）符号位会变成1，下溢也是同理（超过1111，机器数会往0000、0001...，符号位变为0）

（2）采用双符号位

结果符号S1S2=   00结果为正，无溢出；

                            01表示结果正溢出；

                           10表示结果负溢出；

                           11结果为负数，无溢出

（3）采用一位符号位根据数据位的进位情况判断溢出

符号位的进位与最高数据位的进位相同，则说明没有溢出，否则发生溢出。

解释：

加法符号位有几种种情况：
```
0+0=0（数据位和符号位均没进位，没溢出）；
0+0=1（符号位没进位，数据位进1位，溢出，上溢）；

0+1=1（符号位和数据位均没进位，没溢出）；
0+1=0（符号位和数据位均进位，没溢出）；

1+1=1（数据位和符号位均进1位，没溢出）；
1+1=0（符号位进1位，数据位没进位，溢出，下溢）
```
综上，溢出的充要条件是符号位进位与数据位进位不同。

溢出标志OF
OF=1表示溢出，OF=0表示没溢出

进位/借位标志CF
CF=1表示最高位向前有进位或游位，CF=0表示最高位没有向前进位或游位。
# 定点数的移位运算
这部分很简单,先看PPT
![算术移位](/image/2/ssyw.png)
![算术移位](/image/2/ssyw1.png)
![算术移位](/image/2/ssyw2.png)
![算术移位](/image/2/ssyw3.png)
![算术移位](/image/2/ssyw4.png)

看了几页PPT有点难理解,其实很简单:
**算术移位（Arithmetic Shift）**
- 左移（Left Shift）：与逻辑左移相同，将所有位向左移动，右边补0。
- 右移（Right Shift）：将所有位向右移动，左边补符号位（即原最高位）。
特点：保留符号位，适用于有符号数的移位操作。

这部分我们要做一个概念辨析,虽然我们说在硬件层面左移或右移一位相当于乘以2或者除以2,且都可能发生溢出现象,但是乘法会有更好的处理措施.相对来说对于**2^n^** 的运算,移位运算更快,但发生溢出后不会有乘法的处理措施作保险,而乘法会更安全一点。
![算术移位](/image/2/ljyw.png)
**逻辑移位（Logical Shift）**
- 左移（Left Shift）：将所有位向左移动，右边补0。
- 右移（Right Shift）：将所有位向右移动，左边补0。
特点：不考虑符号位，适用于无符号数的移位操作。

## 示例(区分逻辑与算术右移)
假设我们有一个8位二进制数 10001010（即十进制的-118，使用补码表示）：

- 逻辑右移一位：10001010 >> 1 变为 01000101，即十进制的69（符号位被移出，结果变为正数）。
- 算术右移一位：10001010 >>> 1 变为 11000101，即十进制的-59（符号位保留，结果仍为负数）。
***

![循环移位](/image/2/xhyw.png)
## 移位操作的作用
移位操作（bit shift operation）在计算机科学中是一种基本的位运算，主要用于对二进制数进行左移或右移操作。以下是移位操作的主要作用和应用：

### 1. 数据处理
- **乘法和除法**：左移操作相当于乘以2的幂次方，右移操作相当于除以2的幂次方。例如，左移一位相当于乘以2，右移一位相当于除以2。
- **快速计算**：移位操作在硬件上实现非常高效，常用于加速某些计算过程。

### 2. 数据加密和解密
- **简单加密**：通过移位操作可以对数据进行简单的加密和解密，增加数据的复杂性和安全性。

### 3. 位控制
- **位操作**：移位操作可以用于控制和操作特定位。例如，通过左移或右移可以设置或清除特定位。

### 4. 循环移位
- **数据循环**：循环移位将移出的位重新引入到另一端，从而形成一个循环。这在某些算法和数据处理过程中非常有用。

### 5. 逻辑运算
- **逻辑判断**：移位操作可以用于逻辑运算，例如位与、位或、位异或等，通过移位可以进行逻辑判断和计算。

### 示例代码
以下是一个简单的C语言实现移位操作的示例：
```c
#include <stdio.h>

// 左移操作
unsigned int left_shift(unsigned int val, int n) {
    return val << n;
}

// 右移操作
unsigned int right_shift(unsigned int val, int n) {
    return val >> n;
}

int main() {
    unsigned int num = 10; // 二进制: 1010
    int n = 2;
    printf("左移: %u\n", left_shift(num, n)); // 输出: 40 (二进制: 101000)
    printf("右移: %u\n", right_shift(num, n)); // 输出: 2 (二进制: 10)
    return 0;
}
```

移位操作在许多场景下都非常有用，特别是在需要高效处理数据和进行位级操作时。
